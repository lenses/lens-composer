<link rel="import" href="../polymer/polymer.html"> 
<link rel="import" href="../lens-node/lens-node.html">
<link rel="import" href="../lenses-component-list/lenses-component-list.html">
<link rel="import" href="../core-animated-pages/core-animated-pages.html">
<link rel="import" href="../core-animated-pages/transitions/slide-from-right.html">


<polymer-element name="lens-composer" attributes="componentList lensTitle lensAuthor nodes theme">
  <template>
    <link rel="stylesheet" href="lens-composer.css">
    
    <div id="tracker"></div>
    <div id="component-list">
      <template repeat="{{component in componentList}}">
        <core-item class="{{component.name}}" on-click="{{_addNodeWithElement}}" label="{{component.friendly}}" data-type="{{component.type}}"></core-item>
      </template>
    </div>
    <!-- <lenses-component-list></lenses-component-list> -->
    
    <div id="nodes">
      <core-animated-pages transitions="slide-from-right"  selected="{{currentNode}}" notap>
      <template repeat="{{node, index in nodes}}">
        
        <div class="node" slide-from-right>
          <template if="{{index > 0}}">
            <div class="arrow-left"  on-tap="{{ moveLeft }}"><</div>
          </template>
          <content select="#{{node.id}}"></content>
          <template if="{{index < nodes.length-1}}">
            <div class="arrow-right"  on-tap="{{ moveRight }}">></div>    
          </template>
        </div>

      </template>
      
      </core-animated-pages>
    </div>
  </template>
  <script>
  // TODO: 
  // - incorporate themes
  // - handle selection of final result
  // - incorporate lens-tracker and component-list
  // - 
    Polymer({
      nodes: [],
      componentList: [
          // {name:'lens-data-table', friendly: 'Data table', type: 'input'},
          {name: 'lens-input-simple-api', friendly: 'API Data Loader', type: 'input'},
          {name:'lens-input-csv', friendly: 'CSV Loader', type: 'input'},
          {name: 'lens-input-enigma', friendly: 'Enigma Data Loader', type: 'input'},
          
          {name:'lens-data-convert-date', friendly: 'Convert Dates', type: 'transform'},
          {name:'lens-data-geocoder-firebase', friendly: 'Geocodes for Map', type: 'transform'},
          {name:'lens-data-groupby', friendly: 'Group Data', type: 'transform'},
          {name:'lens-data-filter', friendly: 'Filter Data', type: 'transform'},
          {name:'lens-data-sort', friendly: 'Sort Data', type: 'transform'},
          {name:'lens-data-split', friendly: 'Split Column', type: 'transform'},
          {name:'lens-data-join', friendly: 'Join Columns', type: 'transform'},
          {name:'lens-data-formula', friendly: 'Math & Trig Functions', type: 'transform'},
          {name:'lens-data-array-func', friendly: 'Map/Reduce Function (JavaScript)', type: 'transform'},

          {name:'lens-viz-am-combo-chart', friendly: 'Bar/Line Combo Chart', type: 'visualize'},
          {name:'lens-viz-g-map', friendly: 'Google Map', type: 'visualize'},
          {name:'lens-viz-mapbox', friendly: 'Mapbox Map', type: 'visualize'},
          {name:'lens-viz-g-bar-chart', friendly: 'Google Bar Chart', type: 'visualize'},
          {name:'lens-viz-g-line-chart', friendly: 'Google Line Graph', type: 'visualize'},
          {name:'lens-viz-g-scatter-bubble', friendly: 'Google Bubble Chart', type: 'visualize'},
          {name:'lens-viz-g-pie-chart', friendly: 'Google Pie Chart', type: 'visualize'},
          {name:'lens-viz-line-chart-touch', friendly: 'Thelma Line Chart', type: 'visualize'},
          {name:'lens-viz-bar-chart-horizontal', friendly: 'Thelma Horizontal Bar Chart', type: 'visualize'},
          {name:'lens-viz-bar-chart', friendly: 'Thelma Bar Chart', type: 'visualize'}
      ],
      _uniqueIdCounter: 0,
      ready: function(){
        var self = this;
        self.fire('lens-composer-ready', self);
        
        self._uniqueIdCounter = self.nodes ? self.nodes.length : 0;

        // self._componentMenu = {
        //   input: self.componentList.filter(function(component){ return component.type == 'input' }),
        //   transform: self.componentList.filter(function(component){ return component.type == 'transform' }),
        //   visualize: self.componentList.filter(function(component){ return component.type == 'visualize' })
        // };

        self._setupNodes();

      },
      recreateLens: function(){

      },
      saveLens: function(){

      },

      /***** PRIVATE METHODS *****/

      _setupNodes: function(){
        var self = this,
            elements = self.querySelectorAll('lens-node'); 

          // If nodes array is given, recreate lens
          if (self.nodes && self.nodes.length){
            
            // Remove potential child elements if they exist to avoid conflicts
            if (elements.length){
              [].forEach.call(elements, function(el, i){
                el.remove();
              });
            }

            // Recreate lens with nodes array
            self.recreateLens(self.nodes);
            
          // Otherwise use child elements to create nodes array
          } else if(elements.length) { 
            [].forEach.call(elements, function(el, i) {
                var elName = el.tagName.toLowerCase();

                // Set unique ID to each element
                el.id = el.id || self._generateUniqueId(elName);
                
                self.nodes.push(
                  { id: el.id, // unique ID
                    tag: el, // DOM element
                    name: elName, // 'lens-node'
                    type: el.type,
                    track: 0,
                    step: i 
                    // TODO: Add track, step, output, components, active, visible
                  }
                );
            });

            this._connectNodes();
          
          // Otherwise create an empty input node
          } else {

            // TODO: Create input node
          }

          
         
      },
      _generateUniqueId: function(elName){
        var self = this;
        
        var uniqueId = elName + '-' + self._uniqueIdCounter;
        
        self._uniqueIdCounter+= 1;

        return uniqueId;
      },
      _addNode: function(e, detail, selection){
        // console.log("add node");
        var self = this,
            type = selection.dataset.type,

            newEl = self._createNewNode('lens-node', type);
          
        var index = this.currentNode + 1;
        var newNode = { 
          name: 'lens-node',
          id: newEl.id,
          tag: newEl,
          type: type
        }

        self.nodes.splice(index,0,newNode); // determine correct place to insert node

        return newNode;

      },
      _createNewNode: function(name, type, id, finalResult){
          var self = this;
          var newEl = document.createElement(name);
          newEl.id = id || self._generateUniqueId(name);
          newEl.type = type; // this should be set when the element is created -- otherwise it doesnt behave the same way
          newEl.finalResult = finalResult;
          
          self.appendChild(newEl);
          return newEl;
      },
      _deleteNode: function(e, detail, selection){
        var self = this;
        // console.log("delete node");
        
        // var index = selection.dataset.index;
        // self.removeChild(self.nodes[index].tag);
        // self.nodes.splice(index, 1)
        // this._connectNodes();
      },
      _connectNodes: function(){
          // var self = this;
          // // console.log("CONNECT NODES");
          // for (var i=1; i<self.nodes.length; i++){
          // (function() {
          //     var source = self.nodes[i-1].tag,
          //         target = self.nodes[i].tag;

          //     if (source && target){
          //       var observer = new PathObserver(source, 'output');     
          //       observer.open(function(newValue, oldValue) {
          //          // console.log(source);
          //          // console.log("output changed!");
          //          // console.log(newValue)
          //          target.input = newValue;
          //       });
          //       target.input = source.output; 
          //     }
              
          // })();

          
        // }

      },
      _addNodeWithElement: function(e, detail, selection){
        var self = this,
            type = selection.dataset.type;

        var node = self._addNode(e, detail, selection);
        node.tag.addElement(e, detail, selection);
        self.moveRight();
        console.log(node);// add element to node

      },
      _addElementToNode: function(e, detail, selection){
        var self = this,
            node = self.nodes[self.currentNode].node,
            name = selection.className,
            directory = "../" + name + "/" + name + ".html",
            pathToEl = this.resolvePath(directory); // construct path to component

        
        // Dynamically create HTML import for component
        Polymer.import([pathToEl], function(){ // TODO: this path is different in the lenscomposer app -- doesnt point to bower_components directory
          var component = {
            name: name
          };
          
          component.tag = document.createElement(name);
          // if (node.type !=="input"){ // if the component is visual, set the input to the data selector output if avail, otherwise the table data
            // self.component.style.height = "100%";
            // self.component.style.width = "100%";
            // self.component.input = self.cloneArray(self.selectedData) || self.cloneArray(self.data);
          // } 
            // if (self.component){
          // self.component.animateOnInit = true;
          // self.component.style.width = "100%";
          // self.getFieldsFromComponent();
          // self.component.input = self.cloneArray(self.selectedData) || self.cloneArray(self.data);
        // }

          node.appendChild(component.tag);
          // node.componentName = selection.label
          // self.setComponentObserver(); // observe changes to output of component
        })
        
      },
      _getComponentState: function(component){

      },
      _removeHTMLfromNode: function(node){
        // delete node.tag;

      },
      moveRight: function () {
        this.currentNode++;
      },
      moveLeft: function () {
        this.currentNode--;
      }

    });
  </script>
</polymer-element>